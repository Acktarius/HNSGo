#!/usr/bin/env python3
"""Extract TLD names from hnsd tld.h and generate Kotlin Tld.kt file."""

import re
import sys
from pathlib import Path

def extract_tlds(tld_h_path):
    """Extract TLD names from tld.h file."""
    tlds = []
    in_names_array = False
    with open(tld_h_path, 'r', encoding='utf-8') as f:
        for line in f:
            # Start extracting when we see HSK_TLD_NAMES array
            if 'HSK_TLD_NAMES[]' in line:
                in_names_array = True
                continue
            
            # Stop when we see the closing brace of the array
            if in_names_array and line.strip() == '};':
                break
            
            # Extract TLD names only from the names array
            if in_names_array:
                match = re.match(r'\s+"([^"]+)",', line)
                if match:
                    tlds.append(match.group(1))
    return tlds

def generate_kotlin(tlds, output_path):
    """Generate Kotlin Tld.kt file."""
    tld_list = ',\n    '.join(f'"{tld}"' for tld in tlds)
    
    kotlin_code = f"""package com.acktarius.hnsgo

/**
 * ICANN TLD list for fast lookup.
 * 
 * This file contains all ICANN TLDs that are reserved in Handshake.
 * When a query comes in for one of these TLDs, we immediately forward
 * to upstream DNS (9.9.9.9 or system DNS) without touching SPV/blockchain.
 * 
 * Based on hnsd/src/tld.h - autogenerated, do not edit manually.
 * 
 * Total TLDs: {len(tlds)}
 */
object Tld {{
    /**
     * Set of all ICANN TLDs (case-insensitive lookup).
     * Using Set for O(1) lookup performance.
     */
    private val ICANN_TLDS = setOf(
        {tld_list}
    ).map {{ it.lowercase() }}.toSet()

    /**
     * Check if a TLD is an ICANN TLD (reserved in Handshake).
     * 
     * @param tld The TLD to check (e.g., "com", "org")
     * @return true if the TLD is ICANN, false if it's a Handshake TLD
     */
    fun isIcannTld(tld: String): Boolean {{
        require(tld.isNotEmpty()) {{ "TLD cannot be empty" }}
        return ICANN_TLDS.contains(tld.lowercase())
    }}

    /**
     * Extract the TLD from a domain name.
     * 
     * @param domain The domain name (e.g., "example.com", "www.example.com")
     * @return The TLD (e.g., "com") or null if invalid
     */
    fun extractTld(domain: String): String? {{
        if (domain.isEmpty()) return null
        
        val parts = domain.lowercase().split('.')
        if (parts.size < 2) return null
        
        return parts.last()
    }}

    /**
     * Check if a domain name uses an ICANN TLD.
     * 
     * @param domain The domain name to check
     * @return true if the domain uses an ICANN TLD, false otherwise
     */
    fun isIcannDomain(domain: String): Boolean {{
        val tld = extractTld(domain) ?: return false
        return isIcannTld(tld)
    }}
}}
"""
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(kotlin_code)
    
    print(f"Generated {output_path} with {len(tlds)} TLDs")

if __name__ == '__main__':
    if len(sys.argv) < 3:
        print("Usage: extract_tlds.py <tld.h path> <output.kt path>")
        sys.exit(1)
    
    tld_h_path = Path(sys.argv[1])
    output_path = Path(sys.argv[2])
    
    if not tld_h_path.exists():
        print(f"Error: {tld_h_path} does not exist")
        sys.exit(1)
    
    tlds = extract_tlds(tld_h_path)
    generate_kotlin(tlds, output_path)

